/**
 * @Author eunji
 */
package machine_test;

public class Other {

/*****单链表相关*****/

    //判断链表是否有环
    //慢指针每次移动一步，快指针每次移动两步
    //若链表无环，则快指针会到达尾节点
    //若链表有环，则两个指针会相遇
    //相遇时，快指针指向头节点，两个指针每次移动一步，下一次相遇的节点就是第一个入环节点

    //判断两个无环链表是否相交
    //遍历两个链表，记录长度和尾节点
    //若尾节点不相等，则两个链表不相交
    //若尾节点相等，则两个链表相交
    //重新遍历链表，较长的链表先移动长度之差的步数，然后两个链表同时遍历，每次移动一步
    //两个指针相遇的节点就是第一个相交的节点

    //判断两个有环链表是否相交
    //遍历两个链表，记录第一个入环节点
    //若入环节点相等，则第一个相交节点位于入环节点处或者之前
    //若入环节点不相等，则从第一个入环节点开始遍历一圈
    //若没有遇到第二个入环节点，则两个链表不相交
    //若遇到第二个节点，则两个链表相交

/*****字符串相关*****/

    //第一个（最后一个）只出现一次的字符

    //子串替换

    //判断两个字符串是否互为变位词
    //遍历第一个字符串，统计每个字符出现的次数，再遍历第二个字符串，递减每个字符出现的次数
    //若最终某个字符出现的次数不为0（大于0，表示第二个字符串含有较少的字符，小于0，表示含有较多的字符），则返回false

    //判断两个字符串是否互为旋转词
    //将第一个字符串与自身拼接成一个新字符串，判断第二个字符串在新字符串中出现的位置（字符串匹配）
    //若存在，则返回true

    //字符串的所有排列


    //字符串的所有组合


    //字符串的交错组成

    //0左边必有1的二进制字符串数量


    //最长不含重复字符子串
    //维护一个哈希表，保存所有字符最近一次出现的位置，从左到右遍历字符串
    //维护一个变量，保存以当前字符的前一个字符结尾的最长不含重复字符子串的开始位置的前一个位置
    //比较上面的前一个位置与当前字符最近一次出现的位置，得到以当前字符结尾的最长不含重复字符子串的长度
    //更新上面的前一个位置，当前字符最近一次出现的位置，最长不含重复字符子串的长度以及结尾字符的位置

    //判断一个较短字符串是否为一个较长字符串的子序列
    //若是子序列，则较短字符串所有的字符将按顺序出现在较长字符串中
    //从左到右同时遍历两个字符串，比较对应的字符
    //若字符相等，则同时向右移动一步，若字符不相等，则较长字符串向右移动一步
    //若较短字符串能够遍历完，则是子序列，否则不是子序列

/*****矩阵相关*****/

    /* 二维数组从左到右，从上到下递增，查找是否存在某元素
     * 从矩阵右上角（或者左下角）的元素开始比较，若相等，则返回
     * 若待查元素大于右上角，排除最上一行，若待查元素小于右上角，排除最右一列
     * 每次排除一行或一列（缩小查找范围），会得到新的子矩阵
     * 依次将待查元素与当前矩阵的右上角比较，直到找到（存在）或越界（不存在）
     */
    public static boolean twoDimensionSearch(int [][] array, int data) {
        if (array == null || array[0] == null)
            return false;
        int row = array.length;
        int column = array[0].length;
        for (int i = 0, j = column - 1; i < row && j >= 0;) {
            if (array[i][j] == data)//找到元素
                return true;
            if (data > array[i][j]) {//待查元素大于右上角
                i++;
            }else {//待查元素小于右上角
                j--;
            }
        }
        return false;
    }

    /* 二维数组从左到右，从上到下递增，查找第K小元素
     *
     */


    /* 由外向里，顺时针遍历矩阵
     */

    //斜向遍历矩阵

    //以矩阵中某位置为起点，只能向上、下、左、右移动
    //求解在最多移动n步的情况下，走出矩阵的路径数，一旦走出矩阵，则不能再进入矩阵
    public static int moveOut(int row, int column, int x, int y, int n) {
        if (x == -1 || x == row || y == -1 || y == column)//在矩阵的外面
            return 1;
        if (n == 0)
            return 0;
        int count = 0;
        count += moveOut(row, column, x - 1, y, n - 1);
        count += moveOut(row, column, x + 1, y, n - 1);
        count += moveOut(row, column, x, y - 1, n - 1);
        count += moveOut(row, column, x, y + 1, n - 1);
        return count;
    }

/*****二叉树相关*****/

    /* 节点之间的最大距离
     * 两个节点的距离为两点简单路径上的节点数
     * 最大距离对应的路径可能位于根节点的左子树，右子树或者跨越两棵子树
     */

    /* 两个节点的最近公共双亲节点（基于后序遍历）
     * 两个节点分别为node1，node2
     * 1.若当前节点为node1，node2或者null，则返回当前节点
     * 2.当前节点左右子树的返回结果分别为left，right
     *  （1）若left，right都不为null，则返回当前节点
     *  （2）若left，right都为null，则返回null
     *  （3）若left，right有一个为null，另一个不为null，则返回不为null的节点
     */
}
